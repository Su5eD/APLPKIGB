plugins {
    id 'groovy'
    id 'java-library'
    id 'maven-publish'
    id 'com.github.ben-manes.versions' version '0.42.0'
    id 'com.github.johnrengelman.shadow' version '7.1.2'
    id 'net.minecraftforge.gradle' version '5.1.+'
    id 'org.cadixdev.licenser' version '0.6.1'
}

import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import com.github.jengelman.gradle.plugins.shadow.transformers.Transformer
import com.github.jengelman.gradle.plugins.shadow.transformers.TransformerContext
import groovy.lang.Closure
import shadow.org.apache.tools.zip.ZipEntry
import shadow.org.apache.tools.zip.ZipOutputStream
import shadow.org.codehaus.plexus.util.IOUtil

class UpdatedGroovyExtensionModuleTransformer implements Transformer {

    private static final GROOVY_EXTENSION_MODULE_DESCRIPTOR_PATH =
            "META-INF/groovy/org.codehaus.groovy.runtime.ExtensionModule" // The only change...

    private static final MODULE_NAME_KEY = 'moduleName'
    private static final MODULE_VERSION_KEY = 'moduleVersion'
    private static final EXTENSION_CLASSES_KEY = 'extensionClasses'
    private static final STATIC_EXTENSION_CLASSES_KEY = 'staticExtensionClasses'

    private static final MERGED_MODULE_NAME = 'MergedByShadowJar'
    private static final MERGED_MODULE_VERSION = '1.0.0'

    private final Properties module = new Properties()

    @Override
    boolean canTransformResource(FileTreeElement element) {
        return element.relativePath.pathString == GROOVY_EXTENSION_MODULE_DESCRIPTOR_PATH
    }

    @Override
    void transform(TransformerContext context) {
        def props = new Properties()
        props.load(context.is)
        props.each { String key, String value ->
            switch (key) {
                case MODULE_NAME_KEY:
                    handle(key, value) {
                        module.setProperty(key, MERGED_MODULE_NAME)
                    }
                    break
                case MODULE_VERSION_KEY:
                    handle(key, value) {
                        module.setProperty(key, MERGED_MODULE_VERSION)
                    }
                    break
                case [EXTENSION_CLASSES_KEY, STATIC_EXTENSION_CLASSES_KEY]:
                    handle(key, value) { String existingValue ->
                        def newValue = "${existingValue},${value}"
                        module.setProperty(key, newValue)
                    }
                    break
            }
        }
    }

    private handle(String key, String value, Closure mergeValue) {
        def existingValue = module.getProperty(key)
        if (existingValue) {
            mergeValue(existingValue)
        } else {
            module.setProperty(key, value)
        }
    }

    @Override
    boolean hasTransformedResource() {
        return module.size() > 0
    }

    @Override
    void modifyOutputStream(ZipOutputStream os, boolean preserveFileTimestamps) {
        ZipEntry entry = new ZipEntry(GROOVY_EXTENSION_MODULE_DESCRIPTOR_PATH)
        entry.time = TransformerContext.getEntryTimestamp(preserveFileTimestamps, entry.time)
        os.putNextEntry(entry)
        IOUtil.copy(toInputStream(module), os)
        os.closeEntry()
    }

    private static InputStream toInputStream(Properties props) {
        def baos = new ByteArrayOutputStream()
        props.store(baos, null)
        return new ByteArrayInputStream(baos.toByteArray())
    }
}

static String getGitCommit() {
    def proc = 'git rev-parse --short HEAD'.execute()
    proc.waitFor()
    return proc.exitValue() ? "ERROR(${proc.exitValue()})" : proc.text.trim()
}

def groovy(def name) {
    return [
            group  : 'org.apache.groovy',
            name   : name == 'stdlib' ? 'groovy' : "groovy-${name}",
            version: project.ext.groovyVersion
    ]
}

version = '1.0.1'
group = 'net.thesilkminer.mc.austin'
archivesBaseName = 'aplpkigb'

java {
    toolchain.languageVersion = JavaLanguageVersion.of(JavaVersion.VERSION_17.majorVersion)
    withSourcesJar()
}

license {
    header(project.file('NOTICE'))

    ext['year'] = Calendar.getInstance().get(Calendar.YEAR)
    ext['name'] = 'TheSilkMiner'
    ext['app'] = 'APLP: KIGB'
}

sourceSets {
    game {}
    plugin {}
}

configurations {
    shade {}
    yeet {}
    api.extendsFrom(shade)

    gameImplementation.extendsFrom minecraft, shade
    pluginImplementation.extendsFrom implementation
}

dependencies {
    pluginImplementation sourceSets.game.output

    testImplementation sourceSets.plugin.output
}

def sharedManifest = manifest {
    attributes([
            "Specification-Title"     : "austins-powerful-language-provider-keeping-it-groovy-baby",
            "Specification-Vendor"    : "TheSilkMiner",
            "Specification-Version"   : "1",
            "Implementation-Title"    : project.name,
            "Implementation-Version"  : project.version,
            "Implementation-Vendor"   : "TheSilkMiner",
            "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
            "GitCommit"               : getGitCommit(),
    ])
}

task groovyJar(type: ShadowJar) {
    archiveClassifier = 'groovy'
    configurations = [project.configurations.shade]
    [
            '**/module-info.class',
            'LICENSE.txt',
            'LICENSE-junit.txt',
            'META-INF/LICENSE.txt',
            'META-INF/LICENSE.md',
            'META-INF/NOTICE.txt',
            '**/*.kotlin-module'
    ].each { exclude it }
}

task pluginJar(type: Jar) {
    archiveClassifier = 'plugin'
    from project.sourceSets.plugin.output
    [
            'LICENSE.txt',
            '**/*.psd',
            'META-INF/services/org.codehaus.groovy.transform.ASTTransformation' // Only needed at compile time
    ].each { exclude it }
    manifest {
        from sharedManifest
        
        attributes([
                "FMLModType": "LANGPROVIDER",
        ])
    }
}

task gameJar(type: Jar) {
    archiveClassifier = 'game'
    from project.sourceSets.game.output
    exclude '**/*.psd'
    
    manifest {
        from sharedManifest
    }
}

jar {
    finalizedBy 'reobfJar'

    from groovyJar
    from pluginJar
    from gameJar

    manifest {
        from sharedManifest
        
        attributes([
                "Automatic-Module-Name": "net.thesilkminer.mc.aplpkigb.boot"
        ])
    }
}

tasks.whenTaskAdded {
    if (it.name == 'prepareRuns') {
        it.dependsOn(jar)
    }
}

shadowJar {
    dependsOn 'reobfJar'
    finalizedBy 'reobfShadowJar'
    
    archiveClassifier = 'transform'
    configurations = []
    [
            '**/module-info.class',
            'LICENSE.txt',
            'LICENSE-junit.txt',
            'META-INF/LICENSE.txt',
            'META-INF/LICENSE.md',
            'META-INF/NOTICE.txt',
            '**/*.kotlin-module',
            '**/*.psd',
            'META-INF/services/org.codehaus.groovy.transform.ASTTransformation' // Only needed at compile time
    ].each { exclude it }
    transform(UpdatedGroovyExtensionModuleTransformer)
    mergeServiceFiles()
}

minecraft {
    mappings channel: 'official', version: '1.18.2'

    runs {
        client {
            workingDirectory project.file('run_client')

            property 'forge.logging.console.level', 'debug'

            lazyToken('minecraft_classpath') {
                tasks.jar.archiveFile.get().asFile.absolutePath
            }

            mods {
                mojotest {
                    source sourceSets.test
                }
            }
        }

        server {
            workingDirectory project.file('run_server')

            property 'forge.logging.console.level', 'debug'

            args 'nogui'

            lazyToken('minecraft_classpath') {
                tasks.jar.archiveFile.get().asFile.absolutePath
            }

            mods {
                mojotest {
                    source sourceSets.test
                }
            }
        }
    }
}

repositories {
    mavenCentral()
}

dependencies {
    minecraft group: 'net.minecraftforge', name: 'forge', version: "${mcVersion}-40.0.5"

    shade groovy('stdlib')
    shade groovy('ant')
    shade groovy('astbuilder')
    yeet groovy('backports-compat-23')
    yeet groovy('binary')
    yeet groovy('bom')
    yeet groovy('bsf')
    shade groovy('cli-picocli')
    yeet groovy('cli-commons')
    shade groovy('contracts')
    yeet groovy('console')
    shade groovy('datetime')
    shade groovy('dateutil')
    yeet groovy('docgenerator')
    shade groovy('ginq')
    yeet groovy('groovydoc')
    yeet groovy('groovysh')
    yeet groovy('jaxb')
    yeet groovy('jmx')
    shade groovy('json')
    shade groovy('jsr223')
    shade groovy('macro')
    shade groovy('macro-library')
    shade groovy('nio')
    yeet groovy('servlet')
    yeet groovy('sql')
    yeet groovy('swing')
    shade groovy('templates')
    shade groovy('test')
    shade groovy('test-junit5')
    yeet groovy('testng')
    shade groovy('toml')
    shade groovy('typecheckers')
    shade groovy('xml')
    shade groovy('yaml')
}

task testJar(type: Jar) {
    dependsOn 'shadowJar'
    finalizedBy 'reobfTestJar'
    
    from sourceSets.test.output
    archiveClassifier = 'test'
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
            artifacts = [jar, sourcesJar, shadowJar]
            artifactId = "aplp-${mcVersion}"
            pom.withXml { node ->
                node.asNode().dependencies
                        .'*'
                        .findAll { it.version.text().contains('mapped') }
                        .each { it.parent().remove(it) }
            }
        }
    }
    repositories {
        maven {
            url = uri("file://${System.getenv("local_maven")}")
        }
    }
}

reobf {
    shadowJar {}
    testJar {}
}

tasks.withType(GroovyCompile).configureEach {
    groovyOptions.optimizationOptions.indy = true
}

tasks.withType(GenerateModuleMetadata).configureEach {
    enabled = false
}

build.dependsOn('testJar')

wrapper {
    gradleVersion = '7.4'
    distributionType = Wrapper.DistributionType.ALL
}
